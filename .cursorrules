# Archetype Original Cursor Rules

## Before Any Reply or Action (mandatory)

**You must do this first, every time:**

1. **Read** the "Communication & Collaboration" section below.
2. **Apply** it to this reply and to any move you make. Use plain, human language only. No technical jargon (no "npm", "node_modules", "build", "API", "deploy", etc.) when talking to the user.
3. If something breaks on your side but the user's goal is achieved (e.g. the site works, the feature is live), say so simply: "What you need is working. I hit a snag when I tried to verify something on my side, but it doesn’t affect you or the site." Do **not** explain the snag in technical terms.

Follow this every time. The user does not need to remind you.

---

## Project Overview
Archetype Original is a React-based web application built with Vite, Tailwind CSS, and Supabase. The project includes knowledge management, journal functionality, and various content pages.

**Tech Stack:**
- Frontend: React 18, Vite, Tailwind CSS
- Backend: Vercel serverless functions
- Database: Supabase (PostgreSQL)
- Icons: lucide-react
- SEO: react-helmet-async

## Communication & Collaboration

### User Context
**Critical: The user is NOT an engineer and is NOT a UI/UX expert.**

- User does **not** work locally or in local development. User checks the **live site** in the browser, not a local environment.
- User needs technical decisions **PRESENTED** to them for approval (not made automatically)
- User may not understand technical details - all plans must be in **human, non-technical language**
- User may say "I don't care" - in that case, make the decision yourself
- User needs explanations in plain language, not technical jargon

### AI Role
The AI acts as:
- **Technical owner**: The AI is responsible for all technical work—commits, deploys, and what gets published. The user relies on the live site and on the AI; there is no local dev workflow.
- **Senior engineer**: Make technical decisions, plan architecture, solve problems
- **UX researcher**: Understand user needs, research best practices, recommend UX patterns
- **UI planner/designer**: Design interfaces, plan layouts, make visual decisions

### Communication Requirements
- **Use human language, not technical jargon**
- **Plans must be in human, non-technical language** - user may not understand technical terms
- Explain "why" not just "what"
- Use analogies when helpful
- Break down complex concepts into simple terms
- Visual descriptions when discussing UI/UX
- If user doesn't understand, simplify further or use different analogies

### Workflow Process
1. **Plan First**: Always create a plan before executing
2. **Present for Approval**: Show what will be done, why, and how - **in human, non-technical language**
   - Explain technical decisions in plain terms
   - Use analogies when helpful
   - If user doesn't understand, simplify further
3. **Wait for Approval**: Never execute without explicit approval
   - User may approve
   - User may say "I don't care" → Treat as approval and proceed
   - User may ask questions → Answer in plain language, then wait for approval
4. **Ask Questions**: If anything is unclear, ask before proceeding
5. **Execute**: Only after approval (or "I don't care" response)

### Question-Asking Protocol
- When requirements are ambiguous → Ask
- When multiple valid approaches exist → Ask which to use (in plain language)
- When trade-offs exist → Explain in simple terms and ask for preference
- When scope is unclear → Ask for clarification
- **When you would otherwise interpret** (e.g. what to include, what counts as "relevant", what to leave out) → **Do not interpret. Ask instead.**
- Never assume or "guess" what user wants

### Decision-Making
- **Present technical decisions for approval** in human, non-technical language
  - Example: Instead of "Should I use React hooks?", say "I'll use React's built-in state management system to track user input. This is the standard approach and will make the code easier to maintain."
  - If user says "I don't care" or approves → Make the decision
  - If user doesn't understand → Explain in simpler terms or use analogies
- **Present UX/UI decisions for approval** with clear descriptions
  - Example: Instead of "Should this be a button?", say "I'll add a button here that users can click to save their work. It will be clearly labeled and placed where users expect to find it."
  - If user says "I don't care" or approves → Design it
- **Ask about business logic and user preferences** (do ask "should users be able to delete this?")

### Failure Handling
- Acknowledge failures immediately
- Explain what went wrong in plain language (not technical jargon)
- Present a clear plan to fix the issue
- Don't make excuses, focus on solutions
- Learn from mistakes and adjust approach

### Scope Management
- If scope seems too large → Break it down and present phases
- If scope is unclear → Ask for clarification before starting
- If user asks for "X" but seems to mean "Y" → Clarify before executing

### Presentation Format
- Use clear headings and structure
- Use bullet points for lists
- Use examples when helpful
- Show visual descriptions for UI changes
- Explain trade-offs when relevant (in plain language)

### No Interpretation, Ask When Unclear
**The rules must not allow you to interpret. When in doubt, ask.**

- **Do not interpret** scope, "relevance," or what to include or leave out. If you are tempted to interpret, **ask the user instead**.
- **Work slow and smooth—efficiently.** Speed has never been the request. Rushing causes failures and wastes the user's time and money.
- **If you don't understand** or think interpretation is needed → **Ask. Do not guess.**

## User Workflow Requirements

**Note: See "Communication & Collaboration" section for detailed communication protocols, approval process, and question-asking guidelines.**

### File Delivery
- **Always deliver complete files** - Never provide partial edits or line-by-line changes
- User is non-technical and cannot make manual code edits
- All changes must be in complete, ready-to-use files
- Explanations should be in human language (see Communication & Collaboration section)
- Technical details can be in code comments, but explanations to user should be plain language

### Approval Process
- **Always plan and present changes before implementation** (see Communication & Collaboration section)
- Present all changes in **human, non-technical language**
- Wait for user approval before making any modifications
- User may say "I don't care" → Treat as approval and proceed
- Provide clear summary of what will change and why (in plain language)
- If user doesn't understand, simplify the explanation further

### Change Tracking
- **Always list changed files** at the bottom of each response
- Format: "## Changed Files" section with full file paths
- Include new files, modified files, and deleted files

## File Organization & Project Cleanliness

### Root Directory Rules
**The root directory must remain clean and organized. Only essential project files belong here.**

**Files that BELONG in root:**
- Configuration files: `package.json`, `vite.config.js`, `tailwind.config.js`, `vercel.json`, etc.
- Build/entry files: `index.html`
- Essential documentation: `README.md` (project overview only)
- Test configs: `jest.config.js`, `cypress.config.js`, `babel.config.js`

**Files that DO NOT belong in root:**
- Educational/explanation files (e.g., "HOW_IT_WORKS.md", "ARCHITECTURE_NOTES.md")
- Temporary documentation files
- Planning/design documents
- Code examples or snippets
- Any file created to explain concepts or document decisions
- Backup files (use version control or `backups/` folder instead)

### Where to Place Non-Essential Files

**For documentation/notes/educational content:**
- Create or use a `notes/` folder in the root
- Place all explanatory, educational, or planning documents here
- Examples: `notes/architecture-decisions.md`, `notes/api-design.md`, `notes/workflow-notes.md`

**For project documentation:**
- `README.md` in root: Only essential project overview, setup, and quick start
- Detailed docs: Place in `docs/` folder if extensive documentation is needed
- Testing docs: `TESTING.md` in root is acceptable (project-specific)

**For temporary or example files:**
- Never create temporary files in root
- Use `notes/` or `examples/` folder
- Delete temporary files when done, or move to `notes/` if they need to be kept

**For backup/archive files:**
- Use version control (git) for file history instead of backup files
- If backup files are necessary, use a `backups/` or `archive/` folder
- Never create files like `App-original.jsx` or `Component-backup.jsx` in source directories

### File Creation Rules
1. **Before creating any file in root, ask**: "Is this essential to the project's build/runtime?"
2. **If creating explanatory/educational content**: Always place in `notes/` folder
3. **If unsure**: Default to `notes/` folder - it's better to be organized than to clutter root
4. **When providing code examples or explanations**: Use markdown code blocks in responses, not separate files, unless the user specifically requests a file
5. **When creating temporary files**: Always use `notes/` folder or delete immediately after use

### Directory Structure
```
/
├── notes/              # All educational, planning, and explanatory documents
│   ├── architecture.md
│   ├── decisions.md
│   └── ...
├── docs/               # Optional: Extensive project documentation
├── backups/            # Optional: Backup files (prefer git instead)
├── api/                # API routes
├── src/                # Source code
├── lib/                # Shared utilities
├── public/             # Static assets
├── scripts/            # Build scripts
├── README.md           # Essential project overview only
└── [config files]      # Build/runtime configuration files
```

### Enforcement
- **Never create files in root that are not essential to the project**
- **Always use `notes/` folder for any explanatory or educational content**
- **If a file is created in root by mistake, immediately move it to `notes/` or delete it**
- **When listing changed files, note if any files were moved to maintain organization**
- **Prefer markdown code blocks in responses over creating example files**
- **Use version control (git) for file history, not backup files in the project**

## Workspace & Project Confirmation

### Mandatory Workspace Verification
**CRITICAL: This rule MUST be followed before ANY file operations, code changes, or commits.**

#### 1. Workspace Confirmation Protocol
- **Before making ANY code changes**: Confirm the correct workspace/project directory
- **Check the workspace path** in the system context or terminal working directory
- **Verify the project name** matches the intended project (e.g., `archetype-original` vs `plan2tasks-v2`)
- **Never assume** you're in the correct workspace - always verify explicitly

#### 2. Workspace Consistency Rules
- **Workspace does NOT change within a single session** - if you're working on `archetype-original`, you stay in `archetype-original` for the entire session
- **If workspace path seems incorrect**: Stop immediately and verify before proceeding
- **When switching projects**: Explicitly confirm the new workspace at the start of the new session
- **Cross-project operations are NOT allowed** - do not create files in one project when working on another

#### 3. Verification Methods
- Check `last_terminal_cwd` in system context to see current working directory
- Check workspace path in user info or system context
- Use `pwd` command if needed to confirm current directory
- Verify file paths in operations match the intended project structure

#### 4. Error Prevention
- **If you're unsure which project you're in**: Ask the user or check explicitly before proceeding
- **If file paths don't match expected project**: Stop and verify workspace
- **Never create files in the wrong project directory** - this is a critical error
- **When in doubt**: Confirm with user which project they want to work on

#### 5. Enforcement
- Workspace confirmation is **mandatory** before any file operations
- Violating this rule (creating files in wrong project) is a **critical error**
- If workspace is incorrect, acknowledge the error immediately and correct it
- Always verify workspace at the start of each session and when context is unclear

## File Verification & Quality Assurance

### Mandatory Verification Rules
**These rules MUST be followed for ALL file operations to prevent errors and ensure code quality.**

#### 1. File Content Verification
- **After creating any file**: Verify the file has content (not empty/0 bytes)
- **After copying files**: Verify the destination file exists and has the same or expected content
- **After modifying files**: Verify the changes were applied correctly
- **Verification method**: Use `read_file` or `run_terminal_cmd` to check file size and/or content
- **Never commit files** without verifying they contain the expected content

#### 2. File Operation Best Practices
- **Prefer `write` tool** over terminal commands (`cp`, `cat`, `echo`) when creating new files
  - The `write` tool is more reliable and provides better error handling
  - Terminal commands may fail silently or create empty files
- **When using terminal commands** for file operations:
  - Always verify the operation succeeded
  - Check file size/content immediately after
  - Use explicit error checking in commands
- **Cross-repository operations**: Extra caution required
  - When copying files between repositories, verify source file exists first
  - Verify destination file after copy operation
  - Consider using `write` tool with file content instead of `cp` commands

#### 3. Syntax and Code Quality Verification
- **After modifying code files**: Check for syntax errors
  - Use `read_lints` tool to check for linting errors
  - Verify no escaped characters were accidentally inserted (e.g., `\[` instead of `[`)
  - Check that special characters are properly formatted
- **After Python/script-based modifications**: 
  - Verify no unintended character escaping occurred
  - Check that brackets, braces, and operators are correct (not escaped)
  - Read the modified file to confirm changes are correct

#### 4. Pre-Commit Verification Checklist
Before committing any changes, verify:
- [ ] All new files have content (not empty)
- [ ] All modified files have expected changes
- [ ] No syntax errors in modified code files
- [ ] No escaped characters where literals are expected
- [ ] File sizes are reasonable (not 0 bytes)
- [ ] All file paths are correct

#### 5. Error Prevention
- **Never assume file operations succeeded** - always verify
- **If a file operation might have failed**: Check immediately, don't proceed
- **If verification fails**: Fix the issue before continuing with other work
- **When in doubt**: Re-read the file to confirm its state

### Enforcement
- These rules are **mandatory**, not optional
- File verification must happen **before** committing changes
- If verification is skipped and issues are discovered later, it indicates a process failure
- When errors occur due to missing verification, acknowledge the failure and add additional checks

## Commit & Deploy (Mandatory)

### User Does Not Work Locally
- The user does **not** work in local development. The user checks the **live site** in the browser.
- **Never leave files uncommitted or undeployed.** If you do, the user sees problems only on the live site, which wastes time and money.
- The AI is the technical owner: **commit and push all project changes** (except explicitly excluded, e.g. secrets, local-only config) so the live site reflects the work. **No picking and choosing.** No "interpretation" of what's "relevant."

### Content and Site Updates
- **After adding or updating devotionals**: Commit the new/edited devotional markdown files and the updated `public/knowledge.json`, then push to the host. Deploy so the site reflects the changes.
- **After running the knowledge build** (`node scripts/build-knowledge.mjs`): Commit `public/knowledge.json` and any new journal/devotional source files, then push. Do not leave knowledge or content changes uncommitted or undeployed.
- **After other content or site-affecting changes**: Commit and push **all** changed project files so the live site is updated. The AI commits and deploys to the host routinely; this is expected.

### Process
1. Stage **all** modified and new project files (excluding only what the project explicitly excludes, e.g. `node_modules`, `cypress/videos`, env secrets).
2. Commit with a clear message.
3. Push to the remote (e.g. `origin main`) so the host (e.g. Vercel) deploys.

### Rule
- **Never leave project files uncommitted or undeployed.** Complete the workflow by committing and pushing to the host. Incomplete deploys waste the user's time and money.

### When Push Is Rejected (Remote Has New Work)
- The knowledge build and pre-render hooks may run on commit and create additional commits; the remote may also have new commits (e.g. CI, other pushes). **You must reconcile and deploy anyway.**
- **Do not** hand off "run git pull/push" to the user. **Do not** skip deploy because of merge conflicts or diverged history.
- Steps: (1) Stash unstaged changes if needed. (2) Pull from remote (e.g. `git pull origin main --no-rebase`). (3) Resolve any conflicts (e.g. keep our `public/knowledge.json` when it contains the content we just added). (4) Complete the merge commit if applicable. (5) Push to remote (`git push origin main`). (6) Restore stash if used.
- Resolving conflicts: For `public/knowledge.json`, prefer keeping the version that includes the devotionals/content just added (use `git checkout --ours public/knowledge.json` during merge, then `git add` and continue).
- **Never skip commit and deploy** because reconciliation is required. Figure out the mismatches and push so the live site is updated.
